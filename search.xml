<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2017%2F09%2F26%2FJavaScript%2F</url>
    <content type="text"><![CDATA[数据类型6种数据类型object对象FunctionArrayDatanumberstringbooleannullundefined隐式转换+/-12345num - 0; //num作为数字来运算num + ''; //num数字作字符处理"37" - 7 //30"37" + 7 //"377" 等于 == 和 严格等于 === 等于 12345“1.23” == 1.230 == falsenull == undefinednew Object() == new Object()[1, 2] == [1, 2] 类型相同，同=== 类型不同，尝试类型转换和比较:12345null == undefined 相等number == string 转number 1 == “1.0&quot; // trueboolean == ? 转number 1 == true // trueobject == number | string 尝试对象转为基本类型 new String(&apos;hi&apos;) == ‘hi’ // true其它：false 严格等于 类型不同，返回false类型相同NaN ≠ NaNnew Object ≠ new Objectnull === nullundefined === undefined 类型检测typeof适合基本类型及function检测，遇到null失效。 [[Class]]通过{}.toString拿到，适合内置对象和基元类型，遇到null和undefined失效(IE678等返回[object Object])。 instanceof适合自定义对象，也可以用来检测原生对象，在不同iframe和window间检测时失效。 当基本类型使用时, 会临时转换成包装类型对象, 用完后会销毁这个对象. 例:123456var a = &quot;string&quot;;alert(a.length);//把变量a包装成字体串对象, 并为它增加属性t=3;a.t = 3//当使用完变量a后, 即释放了包装对象, 所以a.t为undefined.alert(a.t) // undefined typeof12345678910typeof 100 === “number”typeof true === “boolean”typeof function () &#123;&#125; === “function”typeof(undefined) ) === “undefined”typeof(new Object() ) === “object”typeof( [1， 2] ) === “object”typeof(NaN ) === “number”typeof(null) === “object”typeof(&apos;string&apos;) === &quot;string&quot; instanceofObject.prototype.toString123456Object.prototype.toString.apply([]); === “[object Array]”;Object.prototype.toString.apply(function()&#123;&#125;); === “[object Function]”;Object.prototype.toString.apply(null); === “[object Null]”Object.prototype.toString.apply(undefined); === “[object Undefined]”IE6/7/8 Object.prototype.toString.apply(null) 返回”[object Object]” constructorduck type运算符优先级delete删除对象的属性 只有对象的configurable为true时, 才可以delete掉对象的属性.1234567var obj = &#123;&#125;;Object.defineProperty(obj, &apos;x&apos;, &#123; configurable : false, value : 1&#125;);delete obj.x; // falseobj.x; // 1 in12window.x = 1;‘x’ in window; // true new123456function Foo()&#123;&#125;Foo.prototype.x = 1;var obj = new Foo();obj.x; // 1obj.hasOwnProperty('x'); // falseobj.__proto__.hasOwnProperty('x'); // true this1234567this; // window (浏览器)var obj = &#123; func : function()&#123; return this; &#125;&#125;;obj.func(); // obj void12void 0 // undefinedvoid(0) // undefined 对象属性123var obj = &#123;&#125;;obj.y = 2;obj.x = 1; javascript属性是可以动态添加的. 属性标签: 标签 获取属性描述信息 123Object.getOwnPropertyDescriptor(&#123;pro : true&#125;, 'pro');// Object &#123;value: true, writable: true, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(&#123;pro : true&#125;, 'a'); // undefined * 例子 123456789101112131415161718// cat: 对象, 'price': 属性名, &#123;&#125; 是属性的标签集Object.defineProperty(cat, 'price', &#123;enumerable : false, value : 1000&#125;);cat.propertyIsEnumerable('price'); // falsecat.hasOwnProperty('price'); // trueif (cat &amp;&amp; cat.legs) &#123; cat.legs *= 2;&#125;if (cat.legs != undefined) &#123; // !== undefined, or, !== null&#125;//严格不等于.if (cat.legs !== undefined) &#123; // only if cat.legs is not undefined&#125; enumerable1234567var o = &#123;x : 1, y : 2, z : 3&#125;;'toString' in o; // trueo.propertyIsEnumerable('toString'); // falsevar key;for (key in o) &#123; console.log(key); // x, y, z&#125; 12345678910111213141516var obj = Object.create(o);obj.a = 4;var key;for (key in obj) &#123; console.log(key); // a, x, y, z&#125;var obj = Object.create(o);obj.a = 4;var key;for (key in obj) &#123; //仅显示对象的属性, 过滤掉原型上的属性 if (obj.hasOwnProperty(key)) &#123; console.log(key); // a &#125;&#125; configurable/writable1234567891011var o = &#123;&#125;;Object.defineProperty(o, 'x', &#123;value : 1&#125;); // writable=false, configurable=falsevar obj = Object.create(o);obj.x; // 1obj.x = 200;obj.x; // still 1, can't change itObject.defineProperty(obj, 'x', &#123;writable:true, configurable:true, value : 100&#125;);obj.x; // 100obj.x = 500;obj.x; // 500 value自定义对象属性definepropertydefineProperties defineProperty自定义属性 123456789101112var person = &#123;&#125;;Object.defineProperty(person, 'name', &#123; configurable : false, writable : false, enumerable : true, value : "Bosn Ma"&#125;);person.name; // Bosn Maperson.name = 1;person.name; // still Bosn Madelete person.name; // false 同时定义多个属性defineProperties 12345678910Object.defineProperties(person, &#123; title : &#123;value : 'fe', enumerable : true&#125;, corp : &#123;value : 'BABA', enumerable : true&#125;, salary : &#123;value : 50000, enumerable : true, writable : true&#125;&#125;);Object.getOwnPropertyDescriptor(person, 'salary');// Object &#123;value: 50000, writable: true, enumerable: true, configurable: false&#125;Object.getOwnPropertyDescriptor(person, 'corp');// Object &#123;value: "BABA", writable: false, enumerable: true, configurable: false&#125; 例子1234567891011121314151617181920212223Object.defineProperties(person, &#123; title : &#123;value : 'fe', enumerable : true&#125;, corp : &#123;value : 'BABA', enumerable : true&#125;, salary : &#123;value : 50000, enumerable : true, writable : true&#125;, luck : &#123; get : function() &#123; return Math.random() &gt; 0.5 ? 'good' : 'bad'; &#125; &#125;, promote : &#123; set : function (level) &#123; this.salary *= 1 + level * 0.1; &#125; &#125;&#125;);Object.getOwnPropertyDescriptor(person, 'salary');// Object &#123;value: 50000, writable: true, enumerable: true, configurable: false&#125;Object.getOwnPropertyDescriptor(person, 'corp');// Object &#123;value: "BABA", writable: false, enumerable: true, configurable: false&#125;person.salary; // 50000person.promote = 2;person.salary; // 60000 删除12345678910var person = &#123;age : 28, title : 'fe'&#125;;delete person.age; // truedelete person['title']; // trueperson.age; // undefineddelete person.age; // truedelete Object.prototype; // false,var descriptor = Object.getOwnPropertyDescriptor(Object, 'prototype');descriptor.configurable; // false delete 不能删除全局变量, 局部变量, 函数声明.但是可以删除隐式的全局变量 123ohNo = 1;window.ohNo; // 1delete ohNo; // true 属性检测12345678var cat = new Object;cat.legs = 4;cat.name = "Kitty";'legs' in cat; // true'abc' in cat; // false//in 会向上查找原型上是否有."toString" in cat; // true, inherited property!!! 1234567cat.hasOwnProperty('legs'); // truecat.hasOwnProperty('toString'); // false// 属性是否可枚举cat.propertyIsEnumerable('legs'); // truecat.propertyIsEnumerable('toString'); // false getter/setter方法12345678910111213var man = &#123; name : 'Bosn', weibo : '@Bosn', get age() &#123; return new Date().getFullYear() - 1988; &#125;, set age(val) &#123; console.log('Age can\'t be set to ' + val); &#125;&#125;console.log(man.age); // 27man.age = 100; // Age can't be set to 100console.log(man.age); // still 27 例子12345678910111213141516171819202122232425var man = &#123; weibo : '@Bosn', $age : null, get age() &#123; if (this.$age == undefined) &#123; return new Date().getFullYear() - 1988; &#125; else &#123; return this.$age; &#125; &#125;, set age(val) &#123; // 用一元运算+ 转换val为数字. val = +val; if (!isNaN(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt; 150) &#123; this.$age = +val; &#125; else &#123; throw new Error('Incorrect val = ' + val); &#125; &#125;&#125;//测试结果:console.log(man.age); // 27man.age = 100;console.log(man.age); // 100;man.age = 'abc'; // error:Incorrect val = NaN get/set与原型链结合123456789function foo() &#123;&#125;Object.defineProperty(foo.prototype, 'z', &#123;get : function()&#123;return 1;&#125;&#125;); var obj = new foo();obj.z; // 1obj.z = 10;obj.z; // still 1 12345Object.defineProperty(obj, 'z', &#123;value : 100, configurable: true&#125;);obj.z; // 100;delete obj.z;obj.z; // back to 1 对象标签proto指向原型class123456789101112var toString = Object.prototype.toString;function getType(o)&#123;return toString.call(o).slice(8,-1);&#125;;toString.call(null); // "[object Null]"getType(null); // "Null"getType(undefined); // "Undefined"getType(1); // "Number"getType(new Number(1)); // "Number"typeof new Number(1); // "object"getType(true); // "Boolean"getType(new Boolean(true)); // "Boolean"` extensible / seal / freeze123456789101112131415161718192021222324var obj = &#123;x : 1, y : 2&#125;;//是否可扩展, 默认true.Object.isExtensible(obj); // true//阻止对象扩展, 对于原有的属性x, y还是可以修改的.Object.preventExtensions(obj);Object.isExtensible(obj); // falseobj.z = 1;obj.z; // undefined, add new property failedObject.getOwnPropertyDescriptor(obj, 'x');// Object &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;//锁定::设置对象上所有属性的configurable=false.Object.seal(obj);Object.getOwnPropertyDescriptor(obj, 'x');// Object &#123;value: 1, writable: true, enumerable: true, configurable: false&#125;Object.isSealed(obj); // true//冻结::设置对象上的所有属性的configurable=false, writable=false.Object.freeze(obj);Object.getOwnPropertyDescriptor(obj, 'x');// Object &#123;value: 1, writable: false, enumerable: true, configurable: false&#125;Object.isFrozen(obj); // true// [caution] not affects prototype chain!!! 对象创建{}字面量方式创建12345678910var obj1 = &#123;x : 1, y : 2&#125;;var obj2 = &#123; x : 1, y : 2, o : &#123; z : 3, n : 4 &#125;&#125;; new/原型链12345678910111213141516171819202122232425262728293031function foo()&#123;&#125;foo.prototype.z = 3;var obj =new foo();obj.y = 2;obj.x = 1;obj.x; // 1obj.y; // 2obj.z; // 3typeof obj.toString; //‘function''z' in obj; // trueobj.hasOwnProperty('z'); // falseobj.z = 5; //仅在obj对象上创建z属性.obj.hasOwnProperty('z'); // truefoo.prototype.z; // still 3obj.z; // 5obj.z = undefined;obj.z; // undefined//如果仍想访问原型上的z, 需要删除对象上的z.delete obj.z; // trueobj.z; // 3//delete只能删除对象的属性, 不能删除原型上的.delete obj.z; // trueobj.z; // still 3!!! Object.createObject.create是系统内置的函数,它会返回一个新创建的对象, 并且这个创建的对象的原型指向这个参数对象.12345var obj = Object.create(&#123;x : 1&#125;);obj.x // 1typeof obj.toString // "function"//由于obj的原型是参数&#123;x:&#125;, 所以x是原型的属性, 而不是对象的属性.obj.hasOwnProperty('x');// false 序列化– JSON.stringify()12345678var obj = &#123;x : 1, y : true, z : [1, 2, 3], nullVal : null&#125;;JSON.stringify(obj); // "&#123;"x":1,"y":true,"z":[1,2,3],"nullVal":null&#125;"obj = &#123;val : undefined, a : NaN, b : Infinity, c : new Date()&#125;;JSON.stringify(obj); // "&#123;"a":null,"b":null,"c":"2015-01-20T14:15:43.910Z"&#125;"obj = JSON.parse('&#123;"x" : 1&#125;');obj.x; // 1 toJSON 自定义-序列化123456789101112var obj = &#123; x : 1, y : 2, o : &#123; o1 : 1, o2 : 2, toJSON : function () &#123; return this.o1 + this.o2; &#125; &#125;&#125;;JSON.stringify(obj); // "&#123;"x":1,"y":2,"o":3&#125;" valueOf 实现基本类型 其他对象方法 1234567891011var obj = &#123;x : 1, y : 2&#125;;obj.toString(); // "[object Object]"obj.toString = function() &#123;return this.x + this.y&#125;;"Result " + obj; // "Result 3", by toString+obj; // 3, from toString//obj.valueOf = function() &#123;return this.x + this.y + 100;&#125;;+obj; // 103, from valueOf"Result " + obj; // still "Result 3" 语句block{}请注意：没有块级作用域 12345if(true)&#123; var ss = 'aaa';&#125;ss"aaa" 1234567function foo() &#123; var a = b = 1;&#125;foo();console.log(typeof a); // ‘undefined’console.log(typeof b); // ‘number’ 如何避免上面函数中变为全局变量.var a=1, b=1; for…in 顺序不确定 enumerable为false时不会出现 for in对象属性时受原型链影响 12345var p;var obj = &#123;x : 1, y: 2&#125;for (p in obj) &#123;&#125; withJS的严格模式下已经禁用with 让JS引擎优化更难 可读性差 可被变量定义代替-严格模式下被禁用 12345678with (&#123;x : 1&#125;) &#123; console.log(x);&#125;with (document.forms[0]) &#123; console.log(name.value);&#125;var form = document.forms[0];console.log(form.name.value); 严格模式严格模式是一种特殊的执行模式，它修复了部分语言上的不足，提供更强的错误检查，并增强安全性。 123function func() &#123; 'use strict';&#125; 123'use strict';function func() &#123;&#125; 不允许用with //SyntaxError不允许未声明的变量被赋值 不允许用with不允许未声明的变量被赋值ReferenceError12345!function() &#123; 'use strict'; x = 1; console.log(window.x);&#125;(); arguments变为参数的静态副本1234!function(a) &#123; arguments[0] = 100; console.log(a); //100&#125;(1); 12345!function(a) &#123; 'use strict'; arguments[0] = 100; console.log(a); //1&#125;(1); 12345!function(a) &#123; 'use strict'; arguments[0].x = 100; console.log(a.x); //100&#125;(&#123;x:1&#125;); delete参数、函数名报错123!function(a) &#123; console.log(delete a); //false&#125;(1); 12345!function(a) &#123; 'use strict'; delete a; //SyntaxError&#125;(1); delete不可配置的属性报错123456!function(a) &#123; var obj = &#123;&#125;; Object.defineProperty(obj, 'a', &#123;configurable : false&#125;); console.log(delete obj.a); //false&#125;(1); 1234567!function(a) &#123; 'use strict'; var obj = &#123;&#125;; Object.defineProperty(obj, 'a', &#123;configurable : false&#125;); delete obj.a; //TypeError&#125;(1); 对象字面量重复属性名报错1234!function() &#123; var obj = &#123;x : 1, x : 2&#125;; console.log(obj.x); //2&#125;(); 1234!function() &#123; 'use strict'; var obj = &#123;x : 1, x : 2&#125;; //SyntaxError&#125;(); 禁止八进制字面量123!function() &#123; console.log(0123); //83&#125;(); 1234!function() &#123; 'use strict'; console.log(0123); //SyntaxError&#125;(); eval, arguments变为关键字，不能作为变量、函数名123456!function() &#123; function eval()&#123;&#125; console.log(eval);&#125;();function eval()&#123;&#125; 1234!function() &#123; 'use strict'; function eval()&#123;&#125; //SyntaxError&#125;(); eval独立作用域1234!function() &#123; eval('var evalVal = 2;'); console.log(typeof evalVal); //number&#125;(); undefined12345!function() &#123; 'use strict'; eval('var evalVal = 2;'); console.log(typeof evalVal); //undefined&#125;(); 其他不允许用with所有变量必须声明, 赋值给为声明的变量报错，而不是隐式创建全局变量。eval中的代码不能创建eval所在作用域下的变量、函数。而是为eval单独创建一个作用域，并在eval返回时丢弃。函数中得特殊对象arguments是静态副本，而不像非严格模式那样，修改arguments或修改参数变量会相互影响。删除configurable=false的属性时报错，而不是忽略禁止八进制字面量，如010 (八进制的8)eval, arguments变为关键字，不可作为变量名、函数名等 一般函数调用时(不是对象的方法调用，也不使用apply/call/bind等修改this)this指向null，而不是全局对象。若使用apply/call，当传入null或undefined时，this将指向null或undefined，而不是全局对象。试图修改不可写属性(writable=false)，在不可扩展的对象上添加属性时报TypeError，而不是忽略。arguments.caller, arguments.callee被禁用 数组数组是值的有序集合。每个值叫做元素，每个元素在数组中都有数字位置编号，也就是索引。JS中的数组是弱类型的，数组中可以含有不同类型的元素。数组元素甚至可以是对象或其它数组。 123456789101112&#123;&#125; =&gt; Object.prototype[] =&gt; Array.prototypevar arr = [];arr.__proto__ === Array.prototype //true/属于Array实例[] instanceof Array; // true//(&#123;&#125;).toString.apply([]) === '[object Array]'; // true//构造器[].constructor === Array; // true 数组 VS. 一般对象 相同: 都可以继承. 数组是对象，对象不一定是数组 都可以当做对象添加删除属性 不同: 数组自动更新length 按索引访问数组常常比访问一般对象属性明显迅速。 数组对象继承Array.prototype上的大量数组操作方法 创建/读写1234567var BAT = ['Alibaba', 'Tencent', 'Baidu'];var students = [&#123;name : 'Bosn', age : 27&#125;, &#123;name : 'Nunnly', age : 3&#125;];var arr = ['Nunnly', 'is', 'big', 'keng', 'B', 123, true, null];var arrInArr = [[1, 2], [3, 4, 5]];var commasArr1 = [1, , 2]; // 1, undefined, 2var commasArr2 = [,,]; // undefined * 2 通过Array构造器创建1234var arr = new Array(); var arrWithLength = new Array(100); // undefined * 100var arrLikesLiteral = new Array(true, false, null, 1, 2, "hi");// 等价于[true, false, null, 1, 2, "hi"]; 读写 123456789var arr = [1, 2, 3, 4, 5];arr[1]; // 2arr.length; // 5arr[5] = 6;arr.length; // 6delete arr[0];arr[0]; // undefined 动态的增删元素12345678910111213141516171819202122232425var arr = [];arr[0] = 1;arr[1] = 2;arr.push(3);arr; // [1, 2, 3]arr[arr.length] = 4; // equal to arr.push(4);arr; // [1, 2, 3, 4]arr.unshift(0);arr; // [0, 1, 2, 3, 4];delete arr[2];arr; // [0, 1, undefined, 3, 4]arr.length; // 52 in arr; // falsearr.length -= 1;arr; // [0, 1, undefined, 3, 4], 4 is removedarr.pop(); // 3 returned by poparr; // [0, 1, undefined], 3 is removedarr.shift(); // 0 returned by shiftarr; // [1, undefined] for…in 迭代123456789var i = 0, n = 10;var arr = [1, 2, 3, 4, 5];for (; i &lt; n; i++) &#123; console.log(arr[i]); // 1, 2, 3, 4, 5&#125;for(i in arr) &#123; console.log(arr[i]); // 1, 2, 3, 4, 5&#125; for…in迭代, 过滤掉原型上的属性 1234567891011Array.prototype.x = 'inherited';for(i in arr) &#123; console.log(arr[i]); // 1, 2, 3, 4, 5, inherited&#125;for(i in arr) &#123; if (arr.hasOwnProperty(i)) &#123; console.log(arr[i]); // 1, 2, 3, 4, 5 &#125;&#125; 二维数组12345678910111213141516171819202122var arr = [[0, 1], [2, 3], [4, 5]];var i = 0, j = 0;var row;for (; i &lt; arr.length; i++) &#123; row = arr[i]; console.log('row ' + i); for (j = 0; j &lt; row.length; j++) &#123; console.log(row[j]); &#125;&#125;//结果:// result:// row 0// 0// 1// row 1// 2// 3// row 2// 4// 5 稀疏数组稀疏数组并不含有从0开始的连续索引。一般length属性值比实际元素个数大。 1234567891011var arr1 = [undefined];var arr2 = new Array(1);0 in arr1; // true0 in arr2; // falsearr1.length = 100;arr1[99] = 123;99 in arr1; // true98 in arr1; // falsevar arr = [,,];0 in arr; // false 字符串和数组 字符串是类数组 字符串不是数组, 是不可变的.字符串上没有数组上的方法,如果要使用数组的一些方法, 需要通过Array.prototype原型来调用. 1234567var str = "hello world";str.charAt(0); // "h"str[1]; // e//字符串不是数组, 但是可以通过数组原型的方法操作字符串.Array.prototype.join.call(str, "_");// "h_e_l_l_o_ _w_o_r_l_d" Array 原型上的方法 数组Array原型上的方法 Array.prototype.join Array.prototype.reverse Array.prototype.sort Array.prototype.concat Array.prototype.slice 切片 Array.prototype.splice 胶接 Array.prototype.forEach (ES5) Array.prototype.map (ES5) Array.prototype.filter (ES5) Array.prototype.every (ES5) Array.prototype.some (ES5) Array.prototype.reduce/reduceRight (ES5) Array.prototype.indexOf/lastIndexOf (ES5) Array.isArray(ES5) join123456789var arr = [1, 2, 3];arr.join(); // "1,2,3"arr.join("_"); // "1_2_3"function repeatString(str, n) &#123; return new Array(n + 1).join(str);&#125;repeatString("a", 3); // "aaa"repeatString("Hi", 5); // "HiHiHiHiHi" indexOf / lastIndexOf 数组检索123456789var arr = [1, 2, 3, 2, 1];arr.indexOf(2); // 1arr.indexOf(99); // -1arr.indexOf(1, 1); // 4arr.indexOf(1, -3); // 4arr.indexOf(2, -1); // -1arr.lastIndexOf(2); // 3arr.lastIndexOf(2, -2); // 3arr.lastIndexOf(2, -3); // 1 forEach12345678910var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123; console.log(x + '|' + index + '|' + (a === arr));&#125;);// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true` every / some 数组判断 数组判断 12345678var arr = [1, 2, 3, 4, 5];arr.every(function(x) &#123; return x &lt; 10;&#125;); // truearr.every(function(x) &#123; return x &lt; 3;&#125;); // false 12345678var arr = [1, 2, 3, 4, 5];arr.some(function(x) &#123; return x === 3;&#125;); // truearr.some(function(x) &#123; return x === 100;&#125;); // false reverse 修改原数组被修改123var arr = [1, 2, 3];arr.reverse(); // [3, 2, 1]arr; // [3, 2, 1] sort 修改1234567891011121314151617181920212223var arr = ["a", "d", "c", "b"];arr.sort(); // ["a", "b", "c", "d"]arr = [13, 24, 51, 3];arr.sort(); // [13, 24, 3, 51]arr; // [13, 24, 3, 51]//原数组被修改.arr.sort(function(a, b) &#123; return a - b;&#125;); // [3, 13, 24, 51]arr = [&#123;age : 25&#125;, &#123;age : 39&#125;, &#123;age : 99&#125;];arr.sort(function(a, b) &#123; return a.age - b.age;&#125;);arr.forEach(function(item) &#123; console.log('age', item.age);&#125;);// result:// age 25// age 39// age 99 splice 修改 原数组被修改 1234567891011var arr = [1, 2, 3, 4, 5];arr.splice(2); // returns [3, 4, 5]arr; // [1, 2];arr = [1, 2, 3, 4, 5];arr.splice(2, 2); // returns [3, 4]arr; // [1, 2, 5];arr = [1, 2, 3, 4, 5];arr.splice(1, 1, 'a', 'b'); // returns [2]arr; // [1, "a", "b", 3, 4, 5] slice 不修改 slice原数组未被修改 12345var arr = [1, 2, 3, 4, 5];arr.slice(1, 3); // [2, 3]arr.slice(1); // [2, 3, 4, 5]arr.slice(1, -1); // [2, 3, 4]arr.slice(-4, -3); // [2] concat 不修改 concat 原数组未被修改 1234567var arr = [1, 2, 3];arr.concat(4, 5); // [1, 2, 3, 4, 5]arr; // [1, 2, 3]arr.concat([10, 11], 13); // [1, 2, 3, 10, 11, 13]arr.concat([1, [2, 3]]); // [1, 2, 3, 1, [2, 3]] filter 不修改* filter不修改原ovxe 12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];arr.filter(function(x, index) &#123; return index % 3 === 0 || x &gt;= 8;&#125;); // returns [1, 4, 7, 8, 9, 10]arr; // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] map 不修改 map不修改原数组 12345var arr = [1, 2, 3];arr.map(function(x) &#123; return x + 10;&#125;); // [11, 12, 13]arr; // [1, 2, 3] reduce / reduceRight 不修改1234567max = arr.reduceRight(function(x, y) &#123; console.log(x + "|" + y); return x &gt; y ? x : y;&#125;);// 6|9// 9|3max; // 9 1234567891011121314var arr = [1, 2, 3];var sum = arr.reduce(function(x, y) &#123; return x + y&#125;, 0); // 6arr; //[1, 2, 3]arr = [3, 9, 6];var max = arr.reduce(function(x, y) &#123; console.log(x + "|" + y); return x &gt; y ? x : y;&#125;);// 3|9// 9|6max; // 9 isArray 是否为数组12345Array.isArray([]); // true[] instanceof Array; // true(&#123;&#125;).toString.apply([]) === '[object Array]'; // true[].constructor === Array; // true 函数函数是一块JavaScript代码，被定义一次，但可执行和调用多次。JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递所以我们也常叫JS中的函数为函数对象。 调用方式 不同的调用方式 直接调用: foo(); 对象方法: o.method(); 构造器: new Foo(); call/apply/bind: func.call(o); 函数声明与函数表达式 函数声明 可以前置12345678function add (a, b) &#123; a = +a; b = +b; if (isNaN(a) || isNaN(b)) &#123; return; &#125; return a + b;&#125; 函数表达式 变量提前为undefined, 函数不前置123456789101112131415161718192021222324252627282930313233// 函数变量// function variablevar add = function (a, b) &#123; // do sth&#125;;// 立即执行函数表达式.// IEF(Immediately Executed Function)//()和!是把函数作为表达式来处理(function() &#123; // do sth&#125;)();!function() &#123; // do sth&#125;();// 将匿名函数对象作为返回值// first-class functionreturn function() &#123; // do sth&#125;;// 命名式函数表达式// NFE (Named Function Expression)var add = function foo (a, b) &#123; // do sth&#125;;alert(add === foo); //IE6~8: false ; IE9:foo is undefined.// 递归调用var func = function nfe() &#123; /** do sth.**/ nfe();&#125; Function构造器 1234567891011121314151617var func = new Function('a', 'b', 'console.log(a + b);');func(1, 2); // 3var func = Function('a', 'b', 'console.log(a + b);');func(1, 2); // 3// CASE 1 =&gt; localVal仍为局部变量Function('var localVal = "local"; console.log(localVal);')();console.log(typeof localVal);// result: local, undefined// CASE 2 =&gt; local不可访问, 全局变量global可以访问.var globalVal = 'global';(function() &#123;var localVal = 'local';Function('console.log(typeof localVal, typeof globalVal);')();&#125;)();// result: undefined, string this全局的this(浏览器)1234console.log(this.document === document); // trueconsole.log(this === window); // truethis.a = 37;console.log(window.a); // 37 一般函数的this(浏览器)12345678910function f1()&#123; return this;&#125;f1() === window; // true, global objectfunction f2()&#123; "use strict"; // see strict mode return this;&#125;f2() === undefined; // true 作为对象方法的函数的this1234567891011121314var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;console.log(o.f()); // logs 37var o = &#123;prop: 37&#125;;function independent() &#123; return this.prop;&#125;o.f = independent;console.log(o.f()); // logs 37 对象原型链上的this1234567var o = &#123;f:function()&#123; return this.a + this.b; &#125;&#125;;// 创建一个对象p, p的原型为对象ovar p = Object.create(o);p.a = 1;p.b = 4;// p.f调用的是原型上的方法, 在原型中可以使用this.访问到p实例的属性.console.log(p.f()); // 5 get/set方法与this12345678910111213141516function modulus()&#123; return Math.sqrt(this.re * this.re + this.im * this.im);&#125;var o = &#123; re: 1, im: -1, get phase()&#123; return Math.atan2(this.im, this.re); &#125;&#125;;// 为对象o定义属性modelus, 并指定其get方法为modulus函数. 在其中也是可以用this来访问对象o的属性的.Object.defineProperty(o, 'modulus', &#123; get: modulus, enumerable:true, configurable:true&#125;);console.log(o.phase, o.modulus); // logs -0.78 1.4142 构造器中的this1234567891011121314function MyClass()&#123; this.a = 37;&#125;var o = new MyClass();console.log(o.a); // 37function C2()&#123; this.a = 37; return &#123;a : 38&#125;;&#125;o = new C2();console.log(o.a); // 38 call/apply方法与this1234567891011121314151617function add(c, d)&#123; return this.a + this.b + c + d;&#125;var o = &#123;a:1, b:3&#125;;// call接收参数列表.add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// apply最后一个参数接收数组.add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34function bar() &#123; console.log( Object.prototype.toString.call(this));&#125;bar.call(7); // "[object Number]" bind方法与this1234567891011function f()&#123; return this.a;&#125;// 绑定是将对象&#123;a:"test"&#125;作为函数f的this. 并返回一个新的g对象.var g = f.bind(&#123;a : "test"&#125;);console.log(g()); // test// g对象并不会因改变对象而改变.var o = &#123;a : 37, f : f, g : g&#125;;console.log(o.f(), o.g()); // 37, test 函数属性 &amp; argumentsfoo.name 函数名foo.length 形参个数arguments.length 实参个数12345678910111213function foo(x, y, z) &#123; arguments.length; // 2 arguments[0]; // 1 arguments[0] = 10; x; // change to 10; arguments[2] = 100; z; // still undefined !!! arguments.callee === foo; // true&#125;foo(1, 2);foo.length; // 3foo.name; // "foo" apply/call第一个参数作为函数this对象; 若为null或undefined时, 函数的this为全局的window对象. 1234567function foo(x, y) &#123; console.log(x, y, this);&#125;foo.call(100, 1, 2); // 1, 2, Number(100)foo.apply(true, [3, 4]); // 3, 4, Boolean(true)foo.apply(null); // undefined, undefined, windowfoo.apply(undefined); // undefined, undefined, window 严格模式下, 第一个参数不会变为默认window对象. 123456function foo(x, y) &#123; 'use strict'; console.log(x, y, this);&#125;foo.apply(null); // undefined, undefined, nullfoo.apply(undefined); // undefined, undefined, undefined bindbind方法* 函数对象的绑定方法是将第一个参数作为函数的this. 并返回一个新的g函数对象. 12345678910111213this.x = 9;var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 81; getX的this是module.var getX = module.getX;getX(); // 9; getX的this是window.var boundGetX = getX.bind(module);boundGetX(); // 81; bind后getX的this是bind的第一个参数module对象. bind与currying* 当第一个参数为null时, 仅改变了参数的绑定. 这样的话就指定了默认的配置 123456function getConfig(colors, size, otherOptions) &#123; console.log(colors, size, otherOptions);&#125;var defaultConfig = getConfig.bind(null, "#CC0000", "1024 * 768");defaultConfig("123"); // #CC0000 1024 * 768 123defaultConfig("456"); // #CC0000 1024 * 768 456 bind与new new创建对象时, 会忽略构造器的return 返回值. 123456789function foo() &#123; this.b = 100; return this.a;&#125;var func = foo.bind(&#123;a:1&#125;);func(); // 1new func(); // &#123;b : 100&#125; bind方法模拟** bind方法是ES5才提供的, 之前是没有的.” 在低版本上模拟bind方法实现 12345678910111213141516171819202122if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('What is trying to be bound is not callable'); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; return fToBind.apply(this instanceof fNOP? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125;;&#125; 闭包在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。from 维基百科 实用例子1234567!function() &#123; var localData = "localData here"; document.addEventListener('click', function()&#123; console.log(localData); &#125;);&#125;(); 1234567891011!function() &#123; var localData = "localData here"; var url = "http://www.baidu.com/"; $.ajax(&#123; url : url, success : function() &#123; // do sth... console.log(localData); &#125; &#125;);&#125;(); 闭包-常见错误之循环闭包1234567document.body.innerHTML = "&lt;div id=div1&gt;aaa&lt;/div&gt;" + "&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;";for (var i = 1; i &lt; 4; i++) &#123; document.getElementById('div' + i). addEventListener('click', function() &#123; alert(i); // all are 4! &#125;);&#125; 正确在循环中使用 1234567for (var i = 1; i &lt; 4; i++) &#123; !function(i) &#123; document.getElementById('div' + i).addEventListener('click', function() &#123; alert(i); // 1, 2, 3 &#125;); &#125;(i);&#125; 闭包-封装* 由于函数中的局部变量在函数执行完成后销毁了. 通过闭包函数持有局部变量, 即可将变量隐藏起来, 只能通过返回的闭包去访问变量. 123456789101112131415161718192021222324252627// 立即执行函数(function() &#123; var _userId = 23492; var _typeId = 'item'; var export = &#123;&#125;; function converter(userId) &#123; return +userId; &#125; export.getUserId = function() &#123; return converter(_userId); &#125; export.getTypeId = function() &#123; return _typeId; &#125; // 向外暴露export对象. window.export = export;&#125;());export.getUserId(); // 23492export.getTypeId(); // itemexport._userId; // undefinedexport._typeId; // undefinedexport.converter; // undefined 作用域 JavaScript是没有块级作用域 JavaScript作用域包括: 全局 函数 eval eval(&quot;var a = 1;&quot;); 利用函数作用域封装12345678910// () 和 ! 可以将函数作为表达式来处理.(function() &#123; // do sth here var a, b;&#125;)();!function() &#123; // do sth here var a, b;&#125;(); Function构造函数中不能访问局部变量 123456function outer() &#123; var i = 1; var func = new Function("console.log(typeof i);"); func(); // undefined&#125;outer(); // undefined ES3执行上下文 Execution Context 抽象概念：执行上下文、变量对象…在ECMA-262 第三版标准规范中定义 JS解释器如何找到我们定义的函数和变量？ 变量对象(Variable Object, 缩写为VO)是一个抽象概念中的“对象”，它用于存储执行上下文中的： 变量 函数声明 函数参数 执行上下文与变量对象 全局上下文的this在浏览器中是window, 在NodeJs中是global对象. 123456789# 执行上下文与变量对象的定义:activeExecutionContext = &#123; VO : &#123; data_var, data_func_declaration, data_func_arguments &#125;&#125;;GlobalContextVO =&gt; (VO === this === global) 例子:12345var a = 10;function test(x) &#123; var b = 20;&#125;test(30); 解析:123456789VO(globalContext) = &#123; a : 10, test : &lt;ref to function&gt;&#125;;// 当执行test(30)后的test函数的执行上下文:VO(test functionContext) = &#123; x : 30, b: 20&#125;; 全局执行上下文 JS在初始化时, 就会将Math String window …放入到全局的VO对象中. 当调用时其实就是访问全局的VO对象中对应的值 12345678910111213141516VO(globalContext) === [[global]];[[global]] = &#123; Math : &lt;...&gt;, String : &lt;...&gt;, isNaN : function() &#123;[Native Code]&#125; ... ... window : global // applied by browser(host)&#125;;GlobalContextVO (VO === this === globaString(10); //[[global]].String(10);window.a = 10; // [[global]].window.a = 10this.b = 20; // [[global]].b = 20; 函数中的激活对象 函数的激活对象是函数调用时会有一个arguments参数 1234567891011VO(functionContext) === AO;AO = &#123; arguments : &lt;Arg0&gt;&#125;;arguments = &#123; callee, length, properties-indexes&#125;; 变量初始化阶段* VO按照如下顺序填充: 函数参数 (若未传⼊入，初始化该参数值为undefined) 把函数的参数放到VO中 函数声明 (若发⽣生命名冲突，会覆盖) 将内部的函数d声明放到VO中 变量声明 (初始化变量值为undefined，若发⽣生命名冲突，会忽略。) 将函数中的变量声明放到VO中 123456789101112131415161718function test(a, b) &#123; var c = 10; function d() &#123;&#125; var e = function _e() &#123;&#125;; (function x() &#123;&#125;); b = 20;&#125;test(10);AO(test) = &#123; a: 10, b: undefined, c: undefined, d: &lt;ref to func "d"&gt; e: undefined&#125;;// 函数表达式不会影响VO// _e函数名不会影响到VO 例子 1234567891011// 函数声明覆盖了参数xfunction foo(x, y, z)&#123;function x()&#123;&#125;; alert(x);&#125; foo(100); // alert: function x()&#123;&#125;// var func; 变量声明被忽略;function foo(x, y, z)&#123;function func()&#123;&#125;; var func; console.log(func);&#125; foo(100);// ƒ func()&#123;&#125;// var func=1; 为函数对象func重新赋值为1; 所以输出为1;function foo(x, y, z)&#123;function func()&#123;&#125;; var func = 1; console.log(func);&#125; foo(100);// 1 代码执行阶段 执行代码 123456789function test(a, b) &#123; var c = 10; function d() &#123;&#125; var e = function _e() &#123;&#125;; (function x() &#123;&#125;); b = 20;&#125;test(10); 初始化阶段 1234567AO(test) = &#123; a: 10, b: undefined, c: undefined, d: &lt;ref to func "d"&gt; e: undefined&#125;; 执行阶段 1234567891011VO['c'] = 10;VO['e'] = function _e() &#123;&#125;;VO['b'] = 20;AO(test) = &#123; a: 10, b: 20, c: 10, d: &lt;reference to FunctionDeclaration "d"&gt; e: function _e() &#123;&#125;;&#125;; 例子 代码如下: 1234567891011121314151617alert(x); // functionvar x = 10;alert(x); // 10x = 20;function x() &#123;&#125;alert(x); // 20if (true) &#123; var a = 1;&#125; else &#123; var b = true;&#125;alert(a); // 1alert(b); // undefined 变量初始化阶段步骤: 函数参数: 由于是在全局环境中, 忽略此步 函数声明: 将function x声明放入VO中 变量声明: 将var声明的变量都前置放入到全局的global VO变量中, 并初始化为undefined; 由于var x与函数x冲而被忽略. 执行阶段 alert(x); 在VO中x是声明的函数对象. x = 10; 将VO中的x改变为Number(10) alert(x); 输出number(10) var a = 1; 为变量a赋值为1; alert(b); b声明了但并未赋值, 所以仍为undefined OOP 面向对象程序设计(Object-oriented programming OOP)是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例，它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性，灵活性和扩展性。 来自于 —-维基百科 概念与实现继承方式 实现继承的方式: 创建一个原型是Person.prototype的新对象, 作为Student的原型, 如此Student既继承了Person原型上的属性和方法, 又可扩展这个新对象,实现对Student原型的定制.Student.prototype = Object.create(Person.prototype); 改变Student原型上的构造器. 否则仍为从Person原型上继承的.Person.Student.prototype.constructor = Student; Object.create()是ES5之后才支持的，在es5之前我们可以写一个模拟的方法. 1234567if (!Object.create) &#123; Object.create = function(proto) &#123; function F() &#123;&#125;; F.prototype = proto; return new F(); &#125;;&#125; 通过指定父类的实例为子类的原型实现继承 (不推荐, new per()在构造器的操作是没有意义的)12345function per() &#123;&#125;;function sor() &#123;&#125;;sor.prototype = new per(); //per构造器中会有无意义的操作.sor.prototype.constructor = sor; 基于原型的继承123456789function Foo() &#123; this.y = 2;&#125;;console.log(Foo.prototype); //objectFoo.prototype.x = 1;var obj3 = new Foo();console.log(obj3.y); //2console.log(obj3.x); //1 函数声明创建Foo()函数，这个函数就会有一个内置的Foo.prototype，并且这个属性是对象，并且是预设的object。 当用new去调用函数的时候，那么构造器也就是说这样一个函数就会作为一个构造器来使用，并且this会指向一个对象，而对象的原型会指向构造器的Foo.prototype属性。obj3实际上会成为Foo构造器中的this，最后会作为返回值，并且在构造器里面调用的时候会把y赋值为2，并且obj3的原型，也就是他的proto会指向Foo.prototype内置属性，最后可以看到obj3.y会返回2，obj3.x会返回1，y是这个对象上的直接量，而x是原型链上的，也就是Foo.prototype的 prototype属性与原型 使用函数声明去中创建一个函数的时候，这个函数就会有一个prototype属性，并且他默认会有两个属性. 一个是constructor:Fooconstructor属性会指向它本身Foo。 另外一个属性是__proto__，__proto__是Foo.prototype的原型，那么他的原型会指向Object.prototype也就是说一般的对象比如用花括号括起来的对象字面量，他也会有__proto__他会指向Object.prototype因此Object.prototype上面的一些方法比如说toString，valueOf才会被每一个一般的对象所使用， 继承实例 继承实例 1234567891011121314151617181920212223242526272829303132333435363738394041function Person(name, age) &#123; this.name = name; this.age = age;&#125;;Person.prototype.hi = function() &#123; console.log('Hi my name is' + this.name + ",I'm" + this.age + "years old new");&#125;;Person.prototype.legs_num = 2;Person.prototype.arms_num = 2;Person.prototype.walk = function() &#123; console.log(this.name + "is walking...");&#125;;function Student(name, age, className) &#123; Person.call(this, name, age); this.className = className;&#125;;//实现继承的方法://1. 创建一个原型是Person.prototype的新对象, 作为Student的原型, 如此Student既继承了Person原型上的属性和方法, 又可扩展这个新对象,实现对Student原型的定制.Student.prototype = Object.create(Person.prototype);//2. 改变Student原型上的构造器. 否则仍为从Person原型上继承的Person.Student.prototype.constructor = Student;Student.prototype.hi = function() &#123; console.log('Hi my name is' + this.name + ",I'm" + this.age + "years old new,and form" + this.className + ".");&#125;;Student.prototype.learn = function(subject) &#123; console.log(this.name + 'is learing' + subject + 'at' + this.className + '.');&#125;;console.log(Student.prototype);var t = new Student("黄继鹏", 23, "class2");t.hi();console.log(t.legs_num);t.walk();t.learn('math') 再谈原型链 返回对象原型Object.getPrototypeOf(obj) 这个图里面说明了上面代码例子的示意图 通过var peng = new Student(“黄继鹏”, 23, “class2”);来创建了一个实例peng。 peng的实例他的原型我们用proto表示，就会指向构造器Student.prototype的属性。 Student.prototype上面有hi和learn方法，Student.prototype是通过Student.prototype = Object.create(Person.prototype);构造的，所以说Student.prototype是一个对象，并且的原型指向Person.prototype。 Person.prototype。也给她设置了很多属性，hi…等。 Person.prototype.hi = function() { console.log(‘Hi my name is’ + this.name + “,I’m” + this.age + “years old new”);};Person.prototype.hi其实是内置的普通对象，内置对象他本身也会有他的原型，他的原型就是Object.prototype。 也就是因为这样所以说随便一个对象才会有hasOwnProperty，valueOf，toString等一些公共的函数，这些函数都是从Object.prototype而来的。 当我们去调用 peng.hi();方法的时候，首先看这个对象上本身有没有hi方法，在本身没有所以会像上查找，差遭到peng原型也就是Student.prototype有这样一个函数方法，所以最终调用的是Student.prototype上面的hi方法。 如果Student.prototype不去写hi方法的时候peng.hi();会去调用Person.prototype.hi这样一个方法， 当我们调用peng.walk();的时候，先找peng上发现没有，然后Student.prototype上面，也没有，Person.prototype有walk所以最终调用结果是Person.prototype上面的walk方法。 那么我想去调用peng.toString的时候也是一层一层向上查找。找到Object.prototype那么最后到null也就是最根源没有了。 特殊情况 并不是所有对象最终原型链上最终都有Object.prototype 123var obj2=Object.create(null);obj2.__proto__ //undefinedobj2.toString() //undefined obj2.create(null)的作用是创建空对象，并且这个对象的原型指向这样一个参数，但是这里参数是null，obj2这个时候他的原型就是undefined，obj2.toString就是undefined那么通过Object.create(null)创建出来的对象，就没有Object.prototype的一些方法。所以说并不是所有的对象都继承Object.prototype 并不是所有的函数对象都有prototype这样一个预制属性的 1234function abc() &#123;&#125;;console.log(abc.prototype);var hh = abc.bind(null);console.log(hh.prototype); 使用es5友谊和bind函数，bind函数是用来修改函数在运行时的this的，bind函数返回的也是一个函数，但是bind函数就没有prototype预设属性。 prototype属性 javascript中的prototype原型，不像java的class，是一旦写好了以后不太容易去动态改变的，但是javascript中原型实际上也是普通的对象，那么意味着在程序运行的阶段我们也可以动态的给prototype添加或者删除一些属性. 1234567891011Student.prototype.x=101;console.log(peng.x);//101Student.prototype=&#123;y:2&#125;;console.log(peng.y);//undefinedconsole.log(peng.x);//101var nunnly=new Student("nunnly", 23, "class3");console.log(nunnly.y);//2console.log(nunnly.x);//undefined 通过过Student.prototype.x=101;把huang的原型动态的添加一个属性x那么我们发现所有的实例都会受到影响， 直接修改Student.prototype={y:2};构造器的属性, 并不能修改已经实例化的对象，也就是说已经实例化的peng他的原型已经指向当时的Student.prototype如果你修改了Student.prototype的话，并不会影响已经创建的实例. 但是再去用new重新实例化对象，那么会发现x不见了，并且y是新的y值。 内置构造器的prototype 为所有的对象都增加一个x属性, 并更改属性配置for…in时不枚举原型上的变量 12345678Object.defineProperty(Object.prototype, 'x', &#123;writable: true,value: 1&#125;);var obj = &#123; y: 3&#125;;console.log(obj.x); //1for (var key in obj) &#123; console.log(key + "=" + obj[key]); //y=3&#125; value:属性的值给属性赋值 writable:如果为false，属性的值就不能被重写。 get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。 set:一旦目标属性被赋值，就会调回此方法。 configurable:如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, -enumerable）的行为将被无效化。 enumerable:是否能在for…in循环中遍历出来或在Object.keys中列举出来。 创建对象-new/原型链12345678910111213141516function foo()&#123;&#125; //定义函数对象 foofoo.prototype.z = 3; //函数对象默认带foo.prototype对象属性 这个对象会作为new实例的对象原型 对象添加z属性=3var obj =new foo(); //用构造器方式构造新的对象obj.y = 2; //通过赋值添加2个属性给objobj.x = 1; //通过new去构造这样一个对象他的主要特点是，他的原型会指向构造器的foo.prototype属性//一般foo.prototype对象他的原型又会指向Object.prototype//Object.prototype他也会有他的原型最后指向null整个原型链的末端obj.x; // 1 //访问obj.x发现对象上有x返回1obj.y; // 2 //访问obj.y发现对象上有x返回2obj.z; // 3 //obj上没有z并不会停止查找，会去查找他的原型foo.prototype.z返回3typeof obj.toString; // ‘function' 这是一个函数，toString是Object.prototype上面的每个对象都有'z' in obj; // true obj.z是从foo.prototype继承而来的，所以说obj里面有zobj.hasOwnProperty('z'); // false 表示z并不是obj直接对象上的，而是对象原型链上的。 instanceof instanceof数据类型判断方法 123456console.log([1, 2] instanceof Array); //trueconsole.log(new Object() instanceof Array); //false'1' instanceof String //false String(1) instanceof String //falsenew String(1) instanceof String //true 左边要求是一个对象instanceof右边要求是一个函数或者说构造器他会判断右边的构造器的 prototype的属性是否出现在左边这个对象的原型链上。 123456789101112function per() &#123;&#125;;function sor() &#123;&#125;;sor.prototype = new per();sor.prototype.constructor = sor;var peng = new sor();var han = new per();console.log(peng instanceof sor); //trueconsole.log(peng instanceof per); //trueconsole.log(han instanceof sor); //falseconsole.log(han instanceof per); //true OOP精碎模拟重载 模拟重载 123456789101112131415161718192021222324252627282930function person() &#123; var args = arguments; if (typeof args[0] === 'object' &amp;&amp; args[0]) &#123; if (args[0].name) &#123; this.name = args[0].name; &#125; if (args[0].age) &#123; this.age = args[0].age; &#125; &#125; else &#123; if (args[0]) &#123; this.name = args[0]; &#125; if (args[1]) &#123; this.age = args[1]; &#125; &#125;&#125;;person.prototype.toString = function() &#123; return "姓名:" + this.name + "年龄:" + this.age&#125;var peng = new person(&#123; name: "继小鹏", age: 23&#125;);console.log(peng.toString()); //姓名:继小鹏年龄:23var peng1 = new person("是你", 23);console.log(peng1.toString()); //姓名:是你年龄:23 调用父类方法和子类重载父类方法 调用父类方法和子类重载父类方法 1234567891011121314151617181920function Person(name) &#123;//基类 this.name=name;&#125;function Student(name,classname)&#123; //学生类 this.classname=classname; //子类调用父类的方法. person.call(this,name);&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Person.prototype.init=function()&#123;&#125;;//子类重载父类的init方法Student.prototype.init=function()&#123; //子类实现中调用父类的方法. Person.prototype.init.apply(this, arguments);&#125; 链式调用 链式调用 12345678910111213function classman() &#123;&#125;//给classman构造器prototype添加addClass属性方法classman.prototype.addClass = function(str) &#123; console.log('calss' + str + 'added'); return this; //return this表示返回classman的实例因为返回了实例那么紧接着后面不需要加mang.ad&#125;var mang = new classman();mang.addClass('classA').addClass('classB').addClass('classC')// calssclassAadded// calssclassBadded// calssclassCadded 抽象类 抽象类 123456789101112131415161718function Detectorlse() &#123; throw new Error("Abstract class can not be invoked directly!");&#125;Detectorlse.detect = function() &#123; console.log('Detcetion starting...');&#125;Detectorlse.stop = function() &#123; console.log('Detector stopped');&#125;Detectorlse.init = function() &#123; throw new Error("Error");&#125;function linkDetector() &#123;&#125;;linkDetector.prototype = Object.create(Detectorlse.prototype)linkDetector.prototype.constructor = linkDetector;//...add methods to LinkDetector... defineProperty(ES5)12345678910111213141516171819function Person(name) &#123; Object.defineProperty(this, 'name', &#123; value: name, enumerable: true &#125;);&#125;;Object.defineProperty(Person, 'arms_num', &#123; value: 2, enumerable: true&#125;);Object.seal(Person.prototype);Object.seal(Person);function student(name, classname) &#123; this.classname = classname; Person.call(this, name);&#125;;student.prototype = Object.create(Person.prototype);student.prototype.constructor = student; 模块化 定义简单模块化 123456789var moduleA;moduleA=function()&#123; var prop=1; function func()&#123;&#125;; return &#123; func:func, prop:prop &#125;&#125;(); 定义简单模块化2 12345678var moduleA;moduleA = new function() &#123; var prop = 1; function func() &#123;&#125;; this.func = func; this.prop = prop;&#125;(); 实践（探测器）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677(function(global) &#123; function DetectorBase(configs) &#123; if (!this instanceof DetectorBase) &#123; throw new Error('Do not invoke without new.'); &#125; this.configs = configs; this.analyze(); &#125; DetectorBase.prototype.detect = function() &#123; throw new Error('Not implemented'); &#125;; DetectorBase.prototype.analyze = function() &#123; console.log('analyze...'); this.data = "###data###"; &#125;; function LinkDetector(links) &#123; DetectorBase.apply(this, arguments); if (!this instanceof LinkDetector) &#123; throw new Error('Do not invoke without new.'); &#125; this.links = links; &#125; function ContainerDetector(containers) &#123; DetectorBase.apply(this, arguments); if (!this instanceof ContainerDetector) &#123; throw new Error('Do not invoke without new.'); &#125; this.containers = containers; &#125; // inherit first inherit(LinkDetector, DetectorBase); inherit(ContainerDetector, DetectorBase); // expand later LinkDetector.prototype.detect = function() &#123; console.log('Loading data:' + this.data); console.log('link detection started.'); console.log('Scaning links:' + this.links); &#125;; ContainerDetector.prototype.detect = function() &#123; console.log('Loading data:' + this.data); console.log('link detection started.'); console.log('Scaning containers:' + this.containers); &#125;; // prevent from being altered Object.freeze(DetectorBase); Object.freeze(DetectorBase.prototype); Object.freeze(LinkDetector); Object.freeze(LinkDetector.prototype); Object.freeze(ContainerDetector); Object.freeze(ContainerDetector.prototype); // export to global object Object.defineProperties(global, &#123; LinkDetector: &#123; value: LinkDetector &#125;, ContainerDetector: &#123; value: ContainerDetector &#125;, DetectorBase: &#123; value: DetectorBase &#125; &#125;); function inherit(subClass, superClass) &#123; subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; &#125;&#125;(this));var containerDetector = new ContainerDetector('#nav #banner #sidebar');containerDetector.detect();var linkDetector = new LinkDetector('https://www.alipay.com https://www.aliyun.com');linkDetector.detect(); 正则与模式匹配 正则表达式(regular expression)是一个描述字符模式的对象。ECMAScript的RegExp类表示正则表达式，而String和RegExp都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数。 一个简单的例子123/\d\d\d/.test("123"); //true/\d\d\d/.test("abc"); //falsenew RegExp("Bosn").test("Hi, Bosn"); //true 三个flag global ignoreCase multiline 12/abc/gim.test("ABC"); //trueRegExp("abc", "mgi" 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 1234 var reg1 = new RegExp("lisong",'ig');var reg2 = new RegExp("lisong");var reg3 = /lisong/ig;var reg4 = /lisong/; RegExp对象的属性 global ignoreCase multiline source 1234/abc/g.global //true/abc/g.ignoreCase //false/abc/g.multiline //false/abc/g.source //"abc" RegExp 对象的方法* compile, exec, test, toString 1234567/abc/.exec("abcdef"); //"abc"/abc/.test("abcde"); //true/abc/.toString(); //"/abc/"var reg = /abc/; reg.compile("def");reg.test("def"); //true 方法 描述 FF IE compile 编译正则表达式。 1 4 exec 检索字符串中指定的值。返回找到的值，并确定其位置。 1 4 test 检索字符串中指定的值。返回 true 或 false。 1 4 RegExp静态属性1234567891011121314151617181920212223var str = "123abc456lisong789hehe"; var regExp = new RegExp("[a-z]+(\\d+)","g"); console.log( regExp.exec(str) ); //["abc456", "456", index: 3, input: "123abc456lisong789hehe"] console.log(RegExp.input); //123abc456lisong789hehe console.log(RegExp.leftContext); //123 console.log(RegExp.rightContext); //lisong789hehe console.log(RegExp.lastMatch); //abc456 console.log(RegExp.lastParen); //456 console.log(RegExp.multiline); //false console.log("-------------------------------") console.log( regExp.exec(str) ); //["lisong789", "789", index: 9, input: "123abc456lisong789hehe"] console.log(RegExp.leftContext); //123abc456 console.log(RegExp.rightContext); //hehe console.log(RegExp.lastMatch); //lisong789 console.log(RegExp.lastParen); //789 console.log("-------------------------------") var regExp2 = /lisong/; regExp2.test("123lisong456"); console.log( regExp.exec(str) ); //null,如果没匹配到不会改变静态属性 console.log(RegExp.leftContext); //123abc456 console.log(RegExp.rightContext); //hehe console.log(RegExp.lastMatch); //abc456 console.log(RegExp.lastParen); //789 String类型与正则相关的方法123456789101112131415String.prototype.search"abcabcdef".search(/(abc)\1/); //0String.prototype.replace "aabbbbcc".replace(/b+?/, "1"); //aa1bbbccString.prototype.match"aabbbbccbbaa".match(/b+/);//["bbbb", index: 2, input: "aabbbbccbbaa"]"aabbbbccbbaa".match(/b+/g); //["bbbb", "bb"]String.prototype.split"aabbbbccbbaa".split(/b+/);// ["aa", "cc", "aa"] Promise1234567891011121314151617181920212223242526272829303132333435363738let checkLogin = function () &#123; return new Promise(function (resolve,reject) &#123; let flag = document.cookie.indexOf("userId")&gt;-1?true:false; if(flag=true)&#123; resolve(&#123; status:0, result:true &#125;) &#125;else&#123; reject("error"); &#125; &#125;)&#125;;let getUserInfo = ()=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; let userInfo = &#123; userId:"101" &#125; resolve(userInfo); &#125;);&#125;checkLogin().then((res)=&gt;&#123; if(res.status==0)&#123; console.log("login success"); return getUserInfo(); &#125;&#125;).catch((error)=&gt;&#123; console.log(`errrs:$&#123;error&#125;`)&#125;).then((res2)=&gt;&#123; console.log(`userId:$&#123;res2.userId&#125;`)&#125;);Promise.all([checkLogin(),getUserInfo()]).then(([res1,res2])=&gt;&#123; console.log(`result1:$&#123;res1.result&#125;,result2:$&#123;res2.userId&#125;`)&#125;)]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo指南]]></title>
    <url>%2F2017%2F01%2F26%2Fhexo%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[GitHub + HexoGitHub Pages是GitHub提供的一项免费服务.每个GitHub账号可以申请一个pages仓库用来存放网页文件.而GitHub在已经安装好了服务器程序以便于浏览器访问这些网页.由于GitHub Pages不支持php和数据库,因此只能在上面部署静态博客框架.Hexo也是现在使用比较广的,也比较简单部署的静态框架.所以我们选择GitHub pages + Hexo来部署我们的博客. 使用hexo搭建部署Github博客初始化博客12345678// 使用npm全局安装Hexonpm install -g hexo-cli// 初始化博客工程 安装依赖npm init &lt;folder&gt;cd &lt;folder&gt;npm install// 安装hexo git提交插件npm install hexo-deployer-git --save 配置博客_config.yml1234567891011121314title: 这里填写博客的标题subtitle: 这里填写博客的副标题description: 这里填写博客的描述author: 这里填写博客的作者language: 这里填写博客的语言,如果是中文填写”zh-CN”timezone: Asia/Shanghaiurl: ”http://kangqiao.github.io“post_asset_folder: true #当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。deploy: type: 这里填写”git” repo: 写”git@github.com:kangqiao/kangqiao.github.io.git” branch: master 如果需要了解更多hexo的配置或者想要做更高级的定制,可以查看官方配置说明 发表一篇文章在终端命令行输入hexo new 文章标题我们可以在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件。 12345678---title: hexo指南date: 2017-07-26 16:06:58tags: [hexo]---你好，欢迎来到我的个人技术博客。![图片](./图片名.png) 保存后，我们进行本地发布 $ hexo server 发布博客到GitHub Pages我们只要在终端执行这样的命令即可：12$ hexo g -d这个命令的意思是使用hexo生成整个博客的网页文件,并且上传到我们刚才repo里面填写的git仓库里.hexo会自动检索我们博客文章的改动,删除,增加,并生成一套新的网页. 或者:12$ hexo generate$ hexo deploy 上传博客工程上一步部署博客到Github以后，我们可以在Github仓库的master分支上看到我们上传的博客文件。但是这个博客文件是不包含hexo配置的，所以我们需要新建分支，使用git指令将带hexo配置的Github工程文件上传到新建的分支上。在本地博客根目录下使用git指令上传项目到Github:123456789101112// git初始化git init// 添加仓库地址git remote add origin https://github.com/用户名/仓库名.git// 新建分支并切换到新建的分支git checkout -b 分支名// 添加所有本地文件到gitgit add .// git提交git commit -m &quot;&quot;// 文件推送到hexo分支git push origin hexo 其他设备上clone下Github上新建的分支的文件到本地在另一台设备上使用git指令下载Github新建分支上的文件:12// 克隆文件到本地git clone -b 分支名 https://github.com/用户名/仓库名.git 本地写文章在source-&gt;_posts文件夹下新建md文件，并编辑好保存后： 同步项目源文件到Github12345678// 添加源文件git add .// git提交git commit -m &quot;&quot;// 先拉原来Github分支上的源文件到本地，进行合并git pull origin 分支名hexo// 比较解决前后版本冲突后，push源文件到Github的分支git push origin 分支名hexo 增加评论功能gitmentHexo博客框架下Gitment取代多说评论 参考 https://hexo.io/zh-cn/ 如何使用github和Hexo搭建个人博客 多设备同步hexo搭建的Github博客]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有向图基本算法--遍历算法]]></title>
    <url>%2F2017%2F01%2F09%2F%E6%9C%89%E5%90%91%E5%9B%BE%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[图的表示图的定义图G定义为V和E的集合G={V, E}，其中V表示图中的所有的顶点集合，E表示的是G中的所有的边的集合。图按照E中的元素是否有方向，分为有向图和无向图。 图的表示方法上面给出的数学上图的定义，那么在计算机中如何表示图？通常意义上，有下面的两种方法：邻接表和邻接矩阵表示法。 无向图的邻接表和邻接矩阵表示如下所示： 有向图的邻接表和邻接矩阵表示如下所示： 根据上面的表示方法，下面定义图G的这种数据结构（邻接表），首先定义图的顶点GraphVertex：12345678910111213141516171819// 顶点显示的符号public char Symbol &#123; get; set; &#125;// 顶点当前颜色public VertexColor Color &#123; get; set; &#125;// 顶点和开始节点之间的距离public int Distance &#123; get; set; &#125;// 广度遍历父节点public GraphVertex Parent &#123; get; set; &#125;// 深度优先搜索中的开始时间public int StartTime &#123; get; set; &#125;// 深度优先搜索中的结束时间public int FinishTime &#123; get; set; &#125;// 顶点对应的边public List&lt;GraphEdge&gt; FollowEdges &#123; get; set; &#125; 定义图G的边的数据结构：123456// 边开始顶点，在邻接表的存储中其实没有必要存储public GraphVertex From &#123; get; set; &#125;// 结束顶点public GraphVertex To &#123; get; set; &#125; // 边权重public int Weight &#123; get; set; &#125; 定义图：123// 数据成员，这里假设的是顶点的symbol是各个不相同的private Hashtable graph = new Hashtable();private int time = 0; 整体上的结构如下： 有向图的深度优先算法基本算法其中d表明的是某个节点第一次被发现的时间点，f表明从节点出发的全部节点已经被发现的时间。 设计实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 深度优先遍历算法public void DepthFirstVisit(GraphVertex v)&#123; // 刚刚被发现，颜色为gray Console.WriteLine(v.Symbol); v.Color = VertexColor.GRAY; this.time++; // 开始时间 v.StartTime = this.time; foreach (GraphEdge edge in v.FollowEdges) &#123; // 还未被发现 if (edge.To.Color == VertexColor.WHITE) &#123; edge.To.Parent = v; DepthFirstVisit(edge.To); &#125; &#125; // 如果边都已经发现完成 v.Color = VertexColor.BLACK; this.time++; v.FinishTime = this.time; &#125;public void DepthFirstTravel()&#123; // 全局时间变量 this.time = 0; // 初始化 GraphVertex v; foreach (DictionaryEntry e in this.graph) &#123; v = (GraphVertex)e.Value; v.Color = VertexColor.WHITE; v.Parent = null; &#125; // 递归调用 // 队所有的顶点 foreach (DictionaryEntry e in this.graph) &#123; v = (GraphVertex)e.Value; // 顶点为白色 if (v.Color == VertexColor.WHITE) &#123; DepthFirstVisit(v); &#125; &#125;&#125; 有向图的遍历算法：广度优先基本算法其中color域表示的是当前某个节点被发现的状态。如果是white表明没有被发现，gray表示当前顶点已经被发现，但是从该节点出发的节点还没有被全部发现。parent域定义的是在搜索算法时父节点。distance域表明的是从节点s到某个发现的节点v的路径距离。 设计实现12345678910111213141516171819202122232425262728293031323334353637383940// 广度优先遍历算法，同时生成广度优先树public void BreadthFirstTravel(GraphVertex s)&#123; // 初始化所有节点 GraphVertex v; foreach (DictionaryEntry e in this.graph) &#123; v = (GraphVertex)e.Value; v.Color = VertexColor.WHITE; v.Distance = int.MaxValue; v.Parent = null; &#125; // 发现第一个节点 s.Color = VertexColor.GRAY; s.Distance = 0; s.Parent = null; // 初始化队列 Queue context = new Queue(); context.Enqueue(s); // 如果队列不空的话 while (context.Count != 0) &#123; // 队首元素出队 v = context.Dequeue() as GraphVertex; Console.WriteLine(v.Symbol); // 遍历v的节点 foreach (GraphEdge item in v.FollowEdges) &#123; if ( item.To.Color == VertexColor.WHITE) &#123; item.To.Color = VertexColor.GRAY; item.To.Distance = v.Distance + 1; item.To.Parent = v; context.Enqueue(item.To); &#125; &#125; v.Color = VertexColor.BLACK; &#125;&#125; 上面的搜索代码结构是比较典型的搜索结构：首先定义队列或者是栈来保存程序运行状态，如果容器不空，取出元素，然后对取出的元素做一些处理。 参考 有向图基本算法–遍历算法 https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)]]></content>
      <tags>
        <tag>算法|图</tag>
      </tags>
  </entry>
</search>
